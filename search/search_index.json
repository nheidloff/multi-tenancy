{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Multi tenancy - architecture and projects \u00b6 ------------------ UNDER CONSTRUCTION ------------------ Multi-tenancy projects \u00b6 Serverless OpenShift Satellite Target architecture serverless : \u00b6 One frontend per tenant, one business logic per tenant. This is a simplified diagram containing the used elements and dependencies. Just a single tenant. This is a simplified diagram containing the used elements and dependencies. Technology Used \u00b6 The example ecommerce mircorservices application is build on following technologies/services/tools/frameworks . Microservices architecture OpenID Connect Jakarta EE MicroProfile IBM Cloud Code Engine Postgres AppID Toolchain Quarkus Vue.js NGINX git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3 Quay Tekton Bash jq sed grep","title":"Architecture and projects"},{"location":"#multi-tenancy-architecture-and-projects","text":"------------------ UNDER CONSTRUCTION ------------------","title":"Multi tenancy - architecture and projects"},{"location":"#multi-tenancy-projects","text":"Serverless OpenShift Satellite","title":"Multi-tenancy projects"},{"location":"#target-architecture-serverless","text":"One frontend per tenant, one business logic per tenant. This is a simplified diagram containing the used elements and dependencies. Just a single tenant. This is a simplified diagram containing the used elements and dependencies.","title":"Target architecture serverless:"},{"location":"#technology-used","text":"The example ecommerce mircorservices application is build on following technologies/services/tools/frameworks . Microservices architecture OpenID Connect Jakarta EE MicroProfile IBM Cloud Code Engine Postgres AppID Toolchain Quarkus Vue.js NGINX git 2.24.1 or higher yarn 1.22.4 or higher Node.js v14.6.0 or higher Apache Maven 3.6.3 Quay Tekton Bash jq sed grep","title":"Technology Used"},{"location":"TBD/","text":"TBD \u00b6","title":"5. TBD"},{"location":"TBD/#tbd","text":"","title":"TBD"},{"location":"create_ibmcloud_account/","text":"Lab 1: Create IBM Cloud Account \u00b6 ------------------ UNDER CONSTRUCTION ------------------ Step 1: Create a PayAsYouGo IBM Cloud Account \u00b6 Open this link and follow the guided steps. Code Engine has a free tier per month and we expect, if you haven't used that free tier in current month, you can execute the workshop without creating any additional costs. Here you find the actual Code Engine pricing .","title":"1. Create an IBM Cloud account"},{"location":"create_ibmcloud_account/#lab-1-create-ibm-cloud-account","text":"------------------ UNDER CONSTRUCTION ------------------","title":"Lab 1: Create IBM Cloud Account"},{"location":"create_ibmcloud_account/#step-1-create-a-payasyougo-ibm-cloud-account","text":"Open this link and follow the guided steps. Code Engine has a free tier per month and we expect, if you haven't used that free tier in current month, you can execute the workshop without creating any additional costs. Here you find the actual Code Engine pricing .","title":"Step 1: Create a PayAsYouGo IBM Cloud Account"},{"location":"open_ibmcloud_shell/","text":"Lab 2: Open IBM Cloud Shell \u00b6 Step 1: Open the IBM Cloud Shell \u00b6 When using the IBM Cloud Shell, no client-side setup is required for this workshop, it comes with all necessary CLIs (command line tools). Use following link to directly open the IBM Cloud Shell . https://cloud.ibm.com/shell In your browser, login to the IBM Cloud Dashboard and open the IBM Cloud Shell from here: Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 50-hour weekly usage limit, your workspace data is removed. Step 2: Verify IBM Cloud Shell \u00b6 Now you are logged on with your IBM Cloud account.","title":"2. Open IBM Cloud Shell"},{"location":"open_ibmcloud_shell/#lab-2-open-ibm-cloud-shell","text":"","title":"Lab 2: Open IBM Cloud Shell"},{"location":"open_ibmcloud_shell/#step-1-open-the-ibm-cloud-shell","text":"When using the IBM Cloud Shell, no client-side setup is required for this workshop, it comes with all necessary CLIs (command line tools). Use following link to directly open the IBM Cloud Shell . https://cloud.ibm.com/shell In your browser, login to the IBM Cloud Dashboard and open the IBM Cloud Shell from here: Note: Your workspace includes 500 MB of temporary storage. This session will close after an hour of inactivity. If you don't have any active sessions for an hour or you reach the 50-hour weekly usage limit, your workspace data is removed.","title":"Step 1: Open the IBM Cloud Shell"},{"location":"open_ibmcloud_shell/#step-2-verify-ibm-cloud-shell","text":"Now you are logged on with your IBM Cloud account.","title":"Step 2: Verify IBM Cloud Shell"},{"location":"serverless_sprint_week_41_objectives/","text":"Objectives for sprint in week 41 serverless \u00b6 These are the main three objectives for this sprint. Running simple ecommerce application on Code Engine Automation of the deployment Documentation of the setup 1 Running simple ecommerce application on Code Engine \u00b6 App ID is configured (DONE) Frontend is integrated with AppID (DONE) Externalize configuration for Service Catalog (DONE) Externalize configuration for AppID (DONE) Backend is integrated with AppID (PENDING) Externalize configuration for AppID (PENDING) Backend is integrated postgres (IN PROGRESS) Externalize configuration for Postgress (IN PROGRESS) Postgres is setup (DONE) 2 Automation of the deployment \u00b6 Installation and setup is more about creation (IN PROGRESS) ( link to the bash script for initial creation ) CI/CD is more about update (IN PROGRESS) ( link to the Toolchain with the tekton pipeline ) 2.1 Differences between creation and update \u00b6 Creation ( link to the bash script for initial creation ) This is a simplified diagram containing the used elements and dependencies. Update ( link to the Toolchain with the tekton pipeline ) This is a simplified diagram containing the used elements and dependencies. 2.2 Used CLIs and APIs for the automation \u00b6 IBM Cloud Services IBM AppID REST API IBM Cloud CLI IBM Code Engine CLI IBM Cloud databases CLI IBM Cloud Container Registry CLI Bash automation Bash jq sed grep 3 Documentation of the setup \u00b6 Automation setup (in progress) Manual setup (pending) Workshop (pending)","title":"Objectives"},{"location":"serverless_sprint_week_41_objectives/#objectives-for-sprint-in-week-41-serverless","text":"These are the main three objectives for this sprint. Running simple ecommerce application on Code Engine Automation of the deployment Documentation of the setup","title":"Objectives for sprint in week 41 serverless"},{"location":"serverless_sprint_week_41_objectives/#1-running-simple-ecommerce-application-on-code-engine","text":"App ID is configured (DONE) Frontend is integrated with AppID (DONE) Externalize configuration for Service Catalog (DONE) Externalize configuration for AppID (DONE) Backend is integrated with AppID (PENDING) Externalize configuration for AppID (PENDING) Backend is integrated postgres (IN PROGRESS) Externalize configuration for Postgress (IN PROGRESS) Postgres is setup (DONE)","title":"1 Running simple ecommerce application on Code Engine"},{"location":"serverless_sprint_week_41_objectives/#2-automation-of-the-deployment","text":"Installation and setup is more about creation (IN PROGRESS) ( link to the bash script for initial creation ) CI/CD is more about update (IN PROGRESS) ( link to the Toolchain with the tekton pipeline )","title":"2  Automation of the deployment"},{"location":"serverless_sprint_week_41_objectives/#21-differences-between-creation-and-update","text":"Creation ( link to the bash script for initial creation ) This is a simplified diagram containing the used elements and dependencies. Update ( link to the Toolchain with the tekton pipeline ) This is a simplified diagram containing the used elements and dependencies.","title":"2.1 Differences between creation and update"},{"location":"serverless_sprint_week_41_objectives/#22-used-clis-and-apis-for-the-automation","text":"IBM Cloud Services IBM AppID REST API IBM Cloud CLI IBM Code Engine CLI IBM Cloud databases CLI IBM Cloud Container Registry CLI Bash automation Bash jq sed grep","title":"2.2 Used CLIs and APIs for the automation"},{"location":"serverless_sprint_week_41_objectives/#3-documentation-of-the-setup","text":"Automation setup (in progress) Manual setup (pending) Workshop (pending)","title":"3  Documentation of the setup"},{"location":"serverless_sprint_week_41_tasks/","text":"Tasks for sprint in week 41 serverless \u00b6 Table of tasks \u00b6 Project tasks/activities in ZenHub link Objectives Status Priority Notes 1 Running simple ecommerce application including Quarkus on Code Engine in progress high Running example: tenant b , tenant a 1.0 - Create a folder for the source code of the applications called code done high Inside the folder the name on the subfolders should refect the appliation name. 1.1 - AppID setup done high 1.2 - AppID integration to frontend done high 1.3 - AppID integration to Backend open high 1.4 - Backend database postgres integration done high 1.5 - Deploy to Code Engine in progress high the intergrated appid frontend and postgress backend is deployed 2 Automation of the deployment in progress high 2.0 - Define a folder structure for the installation/setup and CI/CD done high one folder call installapp (first time installation) cicd (continuous delivery realization with tekton) 2.1 - Create containers and save them in a public container registry open high 2.2 - Create a bash automation for the creation and configuration of AppID inprogress high Thomas need to copy the work he did the the project. 2.3 - Create a bash automation for the creation and configuration of postgres open high 2.4 - Create a bash automation for deployment to Code Engine in progress high 2.5 - Setup tekton using the IBM Cloud toolchain in progress high 2.6 - Integrate exiting bash automations to tekton pipeline open high 2.7 - Add an admin UI for onboarding of new tenant roberts application open low 2.7 - Problem to start the frontend container in code engine open high 3 Documenation of the setup open high We should use mkdocs 3.1 - Manual setup open high 3.2 - Automation setup open high 3.3 - Workshop open low","title":"Tasks"},{"location":"serverless_sprint_week_41_tasks/#tasks-for-sprint-in-week-41-serverless","text":"","title":"Tasks for sprint in week 41 serverless"},{"location":"serverless_sprint_week_41_tasks/#table-of-tasks","text":"Project tasks/activities in ZenHub link Objectives Status Priority Notes 1 Running simple ecommerce application including Quarkus on Code Engine in progress high Running example: tenant b , tenant a 1.0 - Create a folder for the source code of the applications called code done high Inside the folder the name on the subfolders should refect the appliation name. 1.1 - AppID setup done high 1.2 - AppID integration to frontend done high 1.3 - AppID integration to Backend open high 1.4 - Backend database postgres integration done high 1.5 - Deploy to Code Engine in progress high the intergrated appid frontend and postgress backend is deployed 2 Automation of the deployment in progress high 2.0 - Define a folder structure for the installation/setup and CI/CD done high one folder call installapp (first time installation) cicd (continuous delivery realization with tekton) 2.1 - Create containers and save them in a public container registry open high 2.2 - Create a bash automation for the creation and configuration of AppID inprogress high Thomas need to copy the work he did the the project. 2.3 - Create a bash automation for the creation and configuration of postgres open high 2.4 - Create a bash automation for deployment to Code Engine in progress high 2.5 - Setup tekton using the IBM Cloud toolchain in progress high 2.6 - Integrate exiting bash automations to tekton pipeline open high 2.7 - Add an admin UI for onboarding of new tenant roberts application open low 2.7 - Problem to start the frontend container in code engine open high 3 Documenation of the setup open high We should use mkdocs 3.1 - Manual setup open high 3.2 - Automation setup open high 3.3 - Workshop open low","title":"Table of tasks"},{"location":"setup_application/","text":"Lab 3: Setup e-commerce example application on IBM Cloud \u00b6 ------------------ UNDER CONSTRUCTION ------------------ Run automated first time installation setup \u00b6 Don't forget you need an IBM Cloud PayAsYouGo Account ! If you don't want to use the IBM Cloud Shell you need to install locally on your Mac: jq ( brew install jq ), IBM Cloud CLI , IBM Code Engine CLI - plugin and IBM Cloud databases CLI - plugin and IBM Cloud Container Registry CLI - plugin . Step 1: Clone the GitHub project to the IBM Cloud Shell \u00b6 Insert these commands to clone the GitHub project to the IBM Cloud Shell . git clone https://github.com/karimdeif/multi-tenancy.git cd multi-tenancy export ROOT_FOLDER = $( pwd ) Step 2: Inspect the default configuration of the setup bash scripts \u00b6 Prerequiste to run the bash scripts ( ce-create-two-tenantcies.sh and ce-install-application.sh for the setup: The container images for the applications need to be available.(in default uses Quay) Verify the default settings for the script execution. The ce-create-two-tenantcies.sh script has following default parameters for Code Engine , Applications , container registry , AppID and Postgres . Code Engine export PROJECT_NAME_A = multi-tenancy-serverless-a export PROJECT_NAME_B = multi-tenancy-serverless-b Applications export SERVICE_CATALOG_NAME_A = \"service-catalog-movies\" export FRONTEND_NAME_A = \"frontend-movies\" export SERVICE_CATALOG_NAME_B = \"service-catalog-fantasy\" export FRONTEND_NAME_B = \"frontend-fantasy\" export CATEGORY_A = Movies export CATEGORY_B = Fantasy IBM CLoud container registry export SERVICE_CATALOG_IMAGE = \"us.icr.io/multi-tenancy-cr/service-catalog:latest\" export FRONTEND_IMAGE = \"us.icr.io/multi-tenancy-cr/frontend:latest\" App ID export APPID_SERVICE_INSTANCE_NAME_A = \"multi-tenancy-serverless-appid-a\" export APPID_SERVICE_KEY_NAME_A = \"multi-tenancy-serverless-appid-key-a\" export APPID_SERVICE_INSTANCE_NAME_B = \"multi-tenancy-serverless-appid-b\" export APPID_SERVICE_KEY_NAME_B = \"multi-tenancy-serverless-appid-key-b\" Postgres export POSTGRES_SERVICE_INSTANCE_A = multi-tenant-pg-a export POSTGRES_SERVICE_INSTANCE_B = multi-tenant-pg-b Step 3: Execute following bash automation \u00b6 Don't worry, this script may take several minutes (10 - 15 min) without portgres. With postgres it will take up to 30 mins. Execute following bash script: cd $ROOT_FOLDER /installapp bash ce-create-two-tenantcies.sh What happens behind the curtain? The bash script ce-create-two-tenantcies.sh invokes twice the bash script ce-install-application.sh with the needed parameter to create two seperated tenant applications. Here is a short simplified description which steps are carried out currently in the script ce-install-application.sh : Configure IBM Cloud configuration for targets like $REGION and create an Code Engine CLI project Configure container the IBM Cloud container registry access in the Code Engine project Create Postgres instance and database Create an App ID service instance Configure the AppID service instance and use the App ID REST API to configure: application , scope , roles , users , login , logo and color . Create service catalog application in the Code Engine project Create frontend application in the Code Engine project Add redirect URI for the Frontend to AppID Verify Code Engine application deployments Show container logs of the applications Showing the URLs After the exection of the script you find your IBM Cloud account: Two App ID service instances which do include an user with the username thomas@example.com and password thomas4appid Two Code Engine projects with a fontend and a backend application and an configured access for the IBM Cloud container registry of your account. Note: We are using at the moment a preconfigured Postgres database running on IBM Cloud, which is maybe not in your cloud account. Verify the setup \u00b6 Step 1: Open following url https://cloud.ibm.com/resources \u00b6 In resource list of the IBM Cloud UI, insert as filter for name the value multi . Now you should see following in your resource list: Step 2: Open App ID instance for tenant a and inspect the configuration \u00b6 Open following URL https://cloud.ibm.com/resources Step 3: Open Code Engine project for tenant a and inspect the configuration \u00b6 Step 4: Open the frontend application for tenant a in the Code Engine project \u00b6 Step 5: Click on URL and logon to the frontend application using username thomas@example.com and password thomas4appid \u00b6 Step 6: Repeat the all steps for tenant b \u00b6 Optional Clean-up \u00b6 Step 1: Inspect the default configuration of the clean-up bash scripts \u00b6 Prerequiste to run the bash scripts ( ce-clean-up-two-tenantcies.sh and ce-clean-up.sh for the clean-up. These are the default values: Code Engine export PROJECT_NAME_A = multi-tenancy-serverless-tmp-a export PROJECT_NAME_B = multi-tenancy-serverless-tmp-b Applications export SERVICE_CATALOG_NAME_A = \"service-catalog-movies\" export FRONTEND_NAME_A = \"frontend-movies\" export SERVICE_CATALOG_NAME_B = \"service-catalog-fantasy\" export FRONTEND_NAME_B = \"frontend-fantasy\" App ID export APPID_SERVICE_INSTANCE_NAME_A = \"multi-tenancy-serverless-appid-a\" export APPID_SERVICE_KEY_NAME_A = \"multi-tenancy-serverless-appid-key-a\" export APPID_SERVICE_INSTANCE_NAME_B = \"multi-tenancy-serverless-appid-b\" export APPID_SERVICE_KEY_NAME_B = \"multi-tenancy-serverless-appid-key-b\" Postgres export POSTGRES_SERVICE_INSTANCE_A = \"multi-tenant-pg-a\" export POSTGRES_SERVICE_INSTANCE_B = \"multi-tenant-pg-b\" export POSTGRES_SERVICE_KEY_NAME_A = \"multi-tenant-pg-service-key-a\" export POSTGRES_SERVICE_KEY_NAME_B = \"multi-tenant-pg-service-key-b\" Step 2: Execute following bash automation in your IBM Cloud Shell \u00b6 Execute following bash script: cd $ROOT_FOLDER /installapp bash ce-clean-up-two-tenantcies.sh Step 3: Verify the App ID services are delete \u00b6 Open following URL https://cloud.ibm.com/resources Step 4: Verify the Code Engine projects are delete \u00b6 Open following URL https://cloud.ibm.com/codeengine/projects Step 4: Verify the IBM CLoud API key is deleted \u00b6 Open following URL https://cloud.ibm.com/iam/apikeys","title":"3. Setup e-commerce example application on IBM Cloud"},{"location":"setup_application/#lab-3-setup-e-commerce-example-application-on-ibm-cloud","text":"------------------ UNDER CONSTRUCTION ------------------","title":"Lab 3: Setup e-commerce example application on IBM Cloud"},{"location":"setup_application/#run-automated-first-time-installation-setup","text":"Don't forget you need an IBM Cloud PayAsYouGo Account ! If you don't want to use the IBM Cloud Shell you need to install locally on your Mac: jq ( brew install jq ), IBM Cloud CLI , IBM Code Engine CLI - plugin and IBM Cloud databases CLI - plugin and IBM Cloud Container Registry CLI - plugin .","title":"Run automated first time installation setup"},{"location":"setup_application/#step-1-clone-the-github-project-to-the-ibm-cloud-shell","text":"Insert these commands to clone the GitHub project to the IBM Cloud Shell . git clone https://github.com/karimdeif/multi-tenancy.git cd multi-tenancy export ROOT_FOLDER = $( pwd )","title":"Step 1: Clone the GitHub project to the IBM Cloud Shell"},{"location":"setup_application/#step-2-inspect-the-default-configuration-of-the-setup-bash-scripts","text":"Prerequiste to run the bash scripts ( ce-create-two-tenantcies.sh and ce-install-application.sh for the setup: The container images for the applications need to be available.(in default uses Quay) Verify the default settings for the script execution. The ce-create-two-tenantcies.sh script has following default parameters for Code Engine , Applications , container registry , AppID and Postgres . Code Engine export PROJECT_NAME_A = multi-tenancy-serverless-a export PROJECT_NAME_B = multi-tenancy-serverless-b Applications export SERVICE_CATALOG_NAME_A = \"service-catalog-movies\" export FRONTEND_NAME_A = \"frontend-movies\" export SERVICE_CATALOG_NAME_B = \"service-catalog-fantasy\" export FRONTEND_NAME_B = \"frontend-fantasy\" export CATEGORY_A = Movies export CATEGORY_B = Fantasy IBM CLoud container registry export SERVICE_CATALOG_IMAGE = \"us.icr.io/multi-tenancy-cr/service-catalog:latest\" export FRONTEND_IMAGE = \"us.icr.io/multi-tenancy-cr/frontend:latest\" App ID export APPID_SERVICE_INSTANCE_NAME_A = \"multi-tenancy-serverless-appid-a\" export APPID_SERVICE_KEY_NAME_A = \"multi-tenancy-serverless-appid-key-a\" export APPID_SERVICE_INSTANCE_NAME_B = \"multi-tenancy-serverless-appid-b\" export APPID_SERVICE_KEY_NAME_B = \"multi-tenancy-serverless-appid-key-b\" Postgres export POSTGRES_SERVICE_INSTANCE_A = multi-tenant-pg-a export POSTGRES_SERVICE_INSTANCE_B = multi-tenant-pg-b","title":"Step 2: Inspect the default configuration of the setup bash scripts"},{"location":"setup_application/#step-3-execute-following-bash-automation","text":"Don't worry, this script may take several minutes (10 - 15 min) without portgres. With postgres it will take up to 30 mins. Execute following bash script: cd $ROOT_FOLDER /installapp bash ce-create-two-tenantcies.sh What happens behind the curtain? The bash script ce-create-two-tenantcies.sh invokes twice the bash script ce-install-application.sh with the needed parameter to create two seperated tenant applications. Here is a short simplified description which steps are carried out currently in the script ce-install-application.sh : Configure IBM Cloud configuration for targets like $REGION and create an Code Engine CLI project Configure container the IBM Cloud container registry access in the Code Engine project Create Postgres instance and database Create an App ID service instance Configure the AppID service instance and use the App ID REST API to configure: application , scope , roles , users , login , logo and color . Create service catalog application in the Code Engine project Create frontend application in the Code Engine project Add redirect URI for the Frontend to AppID Verify Code Engine application deployments Show container logs of the applications Showing the URLs After the exection of the script you find your IBM Cloud account: Two App ID service instances which do include an user with the username thomas@example.com and password thomas4appid Two Code Engine projects with a fontend and a backend application and an configured access for the IBM Cloud container registry of your account. Note: We are using at the moment a preconfigured Postgres database running on IBM Cloud, which is maybe not in your cloud account.","title":"Step 3: Execute following bash automation"},{"location":"setup_application/#verify-the-setup","text":"","title":"Verify the setup"},{"location":"setup_application/#step-1-open-following-url-httpscloudibmcomresources","text":"In resource list of the IBM Cloud UI, insert as filter for name the value multi . Now you should see following in your resource list:","title":"Step 1: Open following url https://cloud.ibm.com/resources"},{"location":"setup_application/#step-2-open-app-id-instance-for-tenant-a-and-inspect-the-configuration","text":"Open following URL https://cloud.ibm.com/resources","title":"Step 2: Open App ID instance for tenant a and inspect the configuration"},{"location":"setup_application/#step-3-open-code-engine-project-for-tenant-a-and-inspect-the-configuration","text":"","title":"Step 3: Open Code Engine project for tenant a and inspect the configuration"},{"location":"setup_application/#step-4-open-the-frontend-application-for-tenant-a-in-the-code-engine-project","text":"","title":"Step 4: Open the frontend application for tenant a in the Code Engine project"},{"location":"setup_application/#step-5-click-on-url-and-logon-to-the-frontend-application-using-username-thomasexamplecom-and-password-thomas4appid","text":"","title":"Step 5: Click on URL and logon to the frontend application using username thomas@example.com and password thomas4appid"},{"location":"setup_application/#step-6-repeat-the-all-steps-for-tenant-b","text":"","title":"Step 6: Repeat the all steps for tenant b"},{"location":"setup_application/#optional-clean-up","text":"","title":"Optional Clean-up"},{"location":"setup_application/#step-1-inspect-the-default-configuration-of-the-clean-up-bash-scripts","text":"Prerequiste to run the bash scripts ( ce-clean-up-two-tenantcies.sh and ce-clean-up.sh for the clean-up. These are the default values: Code Engine export PROJECT_NAME_A = multi-tenancy-serverless-tmp-a export PROJECT_NAME_B = multi-tenancy-serverless-tmp-b Applications export SERVICE_CATALOG_NAME_A = \"service-catalog-movies\" export FRONTEND_NAME_A = \"frontend-movies\" export SERVICE_CATALOG_NAME_B = \"service-catalog-fantasy\" export FRONTEND_NAME_B = \"frontend-fantasy\" App ID export APPID_SERVICE_INSTANCE_NAME_A = \"multi-tenancy-serverless-appid-a\" export APPID_SERVICE_KEY_NAME_A = \"multi-tenancy-serverless-appid-key-a\" export APPID_SERVICE_INSTANCE_NAME_B = \"multi-tenancy-serverless-appid-b\" export APPID_SERVICE_KEY_NAME_B = \"multi-tenancy-serverless-appid-key-b\" Postgres export POSTGRES_SERVICE_INSTANCE_A = \"multi-tenant-pg-a\" export POSTGRES_SERVICE_INSTANCE_B = \"multi-tenant-pg-b\" export POSTGRES_SERVICE_KEY_NAME_A = \"multi-tenant-pg-service-key-a\" export POSTGRES_SERVICE_KEY_NAME_B = \"multi-tenant-pg-service-key-b\"","title":"Step 1: Inspect the default configuration of the clean-up bash scripts"},{"location":"setup_application/#step-2-execute-following-bash-automation-in-your-ibm-cloud-shell","text":"Execute following bash script: cd $ROOT_FOLDER /installapp bash ce-clean-up-two-tenantcies.sh","title":"Step 2: Execute following bash automation in your IBM Cloud Shell"},{"location":"setup_application/#step-3-verify-the-app-id-services-are-delete","text":"Open following URL https://cloud.ibm.com/resources","title":"Step 3: Verify the App ID services are delete"},{"location":"setup_application/#step-4-verify-the-code-engine-projects-are-delete","text":"Open following URL https://cloud.ibm.com/codeengine/projects","title":"Step 4: Verify the Code Engine projects are delete"},{"location":"setup_application/#step-4-verify-the-ibm-cloud-api-key-is-deleted","text":"Open following URL https://cloud.ibm.com/iam/apikeys","title":"Step 4: Verify the IBM CLoud API key is deleted"},{"location":"vue-appid-frontend/","text":"Using App ID in a Vue.js frontend \u00b6 Add App ID client SDK \u00b6 App ID client SDK for Single WebPage How to implement await in JavaScript Client SDK JavaScript npm install ibmcloud-appid-js To use refresh token, you need to enable refresh token, as you see in the image below. Use the App ID client SDK in Vue.js \u00b6 Relevant code in the main.js file. The code is structured in : Set variable for authentication Functions Login ( appID.Signin() ) Renew ( appID.silentSignin() ) App ID authentication init Create vue appilcation instance Renew token in an interval (https://www.unixtimestamp.com/index.php) import AppID from 'ibmcloud-appid-js' ; ... /**********************************/ /* Set variable for authentication /**********************************/ let appid_init ; let user_info ; /**********************************/ /* Functions /**********************************/ async function asyncAppIDInit ( appID ) { var appID_init_Result = await appID . init ( initOptions ); console . log ( \"--> log: appID_init_Result \" , appID_init_Result ); /**********************************/ /* Check if the user is already authenticated /**********************************/ if ( ! store . state . user . isAuthenticated ) { try { /******************************/ /* Authentication /******************************/ let tokens = await appID . signin (); console . log ( \"--> log: tokens \" , tokens ); user_info = { isAuthenticated : true , idToken : tokens . idToken , accessToken : tokens . accessToken , name : tokens . idTokenPayload . given_name } store . commit ( \"login\" , user_info ); return true ; } catch ( e ) { console . log ( \"--> log: error \" , e ); return false ; } } } async function asyncAppIDrefresh ( appID ) { if ( store . state . user . isAuthenticated == true ) { try { /******************************/ /* Authentication /******************************/ let tokens = await appID . silentSignin (); console . log ( \"--> log: silentSignin tokens \" , tokens ); user_info = { isAuthenticated : true , idToken : tokens . idToken , accessToken : tokens . accessToken // name : tokens.idTokenPayload.given_name } store . commit ( \"login\" , user_info ); return true ; } catch ( e ) { console . log ( \"--> log: catch interval error \" , e ); return false ; } } else { console . log ( \"--> log: no refresh \" ); return false ; } } /**********************************/ /* App ID authentication init /**********************************/ appid_init = { //web-app-tenant-a-single appid_clientId : window . VUE_APPID_CLIENT_ID , appid_discoveryEndpoint : window . VUE_APPID_DISCOVERYENDPOINT } console . log ( \"--> log: appid_init\" , appid_init ); store . commit ( \"setAppID\" , appid_init ); let initOptions = { clientId : store . state . appid_init . appid_clientId , discoveryEndpoint : store . state . appid_init . appid_discoveryEndpoint } /**********************************/ /* Create vue appication instance /**********************************/ let appID = new AppID (); let init_messsage = \"\" ; if ( ! ( init_messsage = asyncAppIDInit ( appID ))) { console . log ( \"--> log: init_messsage : \" + init_messsage ); window . location . reload (); } else { console . log ( \"--> log: init_messsage : \" + init_messsage ); // Vue application instance new Vue ({ store , router , render : h => h ( App ) }). $mount ( '#app' ) } /**********************************/ /* App ID authentication renew_token with silentSignin /**********************************/ let renew_token ; setInterval (() => { console . log ( \"--> log: token interval \" ); console . log ( \"--> log: isAuthenticated \" , store . state . user . isAuthenticated ); if ( store . state . user . isAuthenticated == false ) { renew_token = asyncAppIDrefresh ( appID ); console . log ( \"--> log: renew_token : \" + renew_token ); } else { console . log ( \"--> log: renew_token : \" + renew_token ); user_info = { isAuthenticated : false , idToken : \" \" , accessToken : \" \" , name : \" \" } store . commit ( \"login\" , user_info ); } }, 10000 );","title":"1. Using App ID in a Vue.js frontend"},{"location":"vue-appid-frontend/#using-app-id-in-a-vuejs-frontend","text":"","title":"Using App ID in a Vue.js frontend"},{"location":"vue-appid-frontend/#add-app-id-client-sdk","text":"App ID client SDK for Single WebPage How to implement await in JavaScript Client SDK JavaScript npm install ibmcloud-appid-js To use refresh token, you need to enable refresh token, as you see in the image below.","title":"Add App ID client SDK"},{"location":"vue-appid-frontend/#use-the-app-id-client-sdk-in-vuejs","text":"Relevant code in the main.js file. The code is structured in : Set variable for authentication Functions Login ( appID.Signin() ) Renew ( appID.silentSignin() ) App ID authentication init Create vue appilcation instance Renew token in an interval (https://www.unixtimestamp.com/index.php) import AppID from 'ibmcloud-appid-js' ; ... /**********************************/ /* Set variable for authentication /**********************************/ let appid_init ; let user_info ; /**********************************/ /* Functions /**********************************/ async function asyncAppIDInit ( appID ) { var appID_init_Result = await appID . init ( initOptions ); console . log ( \"--> log: appID_init_Result \" , appID_init_Result ); /**********************************/ /* Check if the user is already authenticated /**********************************/ if ( ! store . state . user . isAuthenticated ) { try { /******************************/ /* Authentication /******************************/ let tokens = await appID . signin (); console . log ( \"--> log: tokens \" , tokens ); user_info = { isAuthenticated : true , idToken : tokens . idToken , accessToken : tokens . accessToken , name : tokens . idTokenPayload . given_name } store . commit ( \"login\" , user_info ); return true ; } catch ( e ) { console . log ( \"--> log: error \" , e ); return false ; } } } async function asyncAppIDrefresh ( appID ) { if ( store . state . user . isAuthenticated == true ) { try { /******************************/ /* Authentication /******************************/ let tokens = await appID . silentSignin (); console . log ( \"--> log: silentSignin tokens \" , tokens ); user_info = { isAuthenticated : true , idToken : tokens . idToken , accessToken : tokens . accessToken // name : tokens.idTokenPayload.given_name } store . commit ( \"login\" , user_info ); return true ; } catch ( e ) { console . log ( \"--> log: catch interval error \" , e ); return false ; } } else { console . log ( \"--> log: no refresh \" ); return false ; } } /**********************************/ /* App ID authentication init /**********************************/ appid_init = { //web-app-tenant-a-single appid_clientId : window . VUE_APPID_CLIENT_ID , appid_discoveryEndpoint : window . VUE_APPID_DISCOVERYENDPOINT } console . log ( \"--> log: appid_init\" , appid_init ); store . commit ( \"setAppID\" , appid_init ); let initOptions = { clientId : store . state . appid_init . appid_clientId , discoveryEndpoint : store . state . appid_init . appid_discoveryEndpoint } /**********************************/ /* Create vue appication instance /**********************************/ let appID = new AppID (); let init_messsage = \"\" ; if ( ! ( init_messsage = asyncAppIDInit ( appID ))) { console . log ( \"--> log: init_messsage : \" + init_messsage ); window . location . reload (); } else { console . log ( \"--> log: init_messsage : \" + init_messsage ); // Vue application instance new Vue ({ store , router , render : h => h ( App ) }). $mount ( '#app' ) } /**********************************/ /* App ID authentication renew_token with silentSignin /**********************************/ let renew_token ; setInterval (() => { console . log ( \"--> log: token interval \" ); console . log ( \"--> log: isAuthenticated \" , store . state . user . isAuthenticated ); if ( store . state . user . isAuthenticated == false ) { renew_token = asyncAppIDrefresh ( appID ); console . log ( \"--> log: renew_token : \" + renew_token ); } else { console . log ( \"--> log: renew_token : \" + renew_token ); user_info = { isAuthenticated : false , idToken : \" \" , accessToken : \" \" , name : \" \" } store . commit ( \"login\" , user_info ); } }, 10000 );","title":"Use the App ID client SDK in Vue.js"},{"location":"vue-using-access-token-quarkus-endpoint/","text":"Vue.js using an accesstoken to invoke Quarkus endpoints \u00b6 Here is one example invokation: < md-menu md-size = \"small\" v-if = \"isAuthenticated == true\" > < md-button md-size = \"small\" md-menu-trigger style = \"color:white;\" > {{ getUserName() }} < md-icon class = \"md-size-x\" > verified_user </ md-icon ></ md-button > < md-menu-content > < md-menu-item v-on:click = \"onCheckTokenClicked()\" > Check token </ md-menu-item > < md-menu-item v-on:click = \"onLogoutClicked()\" > Logout </ md-menu-item > </ md-menu-content > </ md-menu > ... Using the REST endpoint of the articles service only on the local machine to verify the accesstoken usage in Quarkus. ... import axios from \"axios\" ; ... export default { name : \"app\" , components : { Catalog }, computed : { isAuthenticated () { return this . $store . state . user . isAuthenticated ; } }, ... methods : { onCheckTokenClicked (){ const axiosService = axios . create ({ timeout : 30000 , headers : { \"Content-Type\" : \"application/json\" , Authorization : \"Bearer \" + this . $store . state . user . accessToken } }); let that = this ; let url = \"http://localhost:8084/articlesA\" ; console . log ( \"--> log: readArticles URL : \" + url ); axiosService . get ( url ) . then ( function ( response ) { that . articles = response . data ; console . log ( \"--> log: readArticles data : \" + that . articles ); that . loading = false ; that . error = \"\" ; }) . catch ( function ( error ) { console . log ( \"--> log: readArticles error: \" + error ); that . loading = false ; that . error = error ; }); },","title":"2. Vue.js using accesstoken to invoke Quarkus endpoints"},{"location":"vue-using-access-token-quarkus-endpoint/#vuejs-using-an-accesstoken-to-invoke-quarkus-endpoints","text":"Here is one example invokation: < md-menu md-size = \"small\" v-if = \"isAuthenticated == true\" > < md-button md-size = \"small\" md-menu-trigger style = \"color:white;\" > {{ getUserName() }} < md-icon class = \"md-size-x\" > verified_user </ md-icon ></ md-button > < md-menu-content > < md-menu-item v-on:click = \"onCheckTokenClicked()\" > Check token </ md-menu-item > < md-menu-item v-on:click = \"onLogoutClicked()\" > Logout </ md-menu-item > </ md-menu-content > </ md-menu > ... Using the REST endpoint of the articles service only on the local machine to verify the accesstoken usage in Quarkus. ... import axios from \"axios\" ; ... export default { name : \"app\" , components : { Catalog }, computed : { isAuthenticated () { return this . $store . state . user . isAuthenticated ; } }, ... methods : { onCheckTokenClicked (){ const axiosService = axios . create ({ timeout : 30000 , headers : { \"Content-Type\" : \"application/json\" , Authorization : \"Bearer \" + this . $store . state . user . accessToken } }); let that = this ; let url = \"http://localhost:8084/articlesA\" ; console . log ( \"--> log: readArticles URL : \" + url ); axiosService . get ( url ) . then ( function ( response ) { that . articles = response . data ; console . log ( \"--> log: readArticles data : \" + that . articles ); that . loading = false ; that . error = \"\" ; }) . catch ( function ( error ) { console . log ( \"--> log: readArticles error: \" + error ); that . loading = false ; that . error = error ; }); },","title":"Vue.js using an accesstoken to invoke Quarkus endpoints"},{"location":"diagrams/","text":"","title":"Index"}]}